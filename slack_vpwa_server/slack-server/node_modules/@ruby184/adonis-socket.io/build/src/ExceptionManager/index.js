"use strict";
/*
 * @ruby184/adonis-socket.io
 *
 * (c) Ľubomír "Ruby" Jesze <lubomir.j184@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExceptionManager = void 0;
/**
 * Exception manager exposes the API to register custom error handler
 * and invoke it when exceptions are raised during the WS lifecycle.
 */
class ExceptionManager {
    constructor(container) {
        this.resolver = container.getResolver();
    }
    /**
     * Register a custom error handler
     */
    registerHandler(handler) {
        if (typeof handler === 'string') {
            this.resolvedErrorHandler = this.resolver.resolve(`${handler}.handle`);
            this.resolvedErrorReporter = this.resolver.resolve(`${handler}.report`);
        }
        else {
            this.resolvedErrorHandler = { type: 'function', handler };
        }
    }
    /**
     * Serialize error to response object which is send to client
     */
    serializeError(error) {
        return {
            name: error.name || 'Error',
            message: error.message,
            data: { status: error.status || 500 },
        };
    }
    /**
     * Handle error
     */
    async handleError(error, ctx) {
        /*
         * Return error message only when no error handler has been registered
         */
        if (!this.resolvedErrorHandler) {
            return this.serializeError(error);
        }
        /*
         * Invoke the error handler and catch any errors raised by the error
         * handler itself. We don't expect error handlers to raise exceptions.
         * However, during development a broken error handler may raise
         * exceptions.
         */
        try {
            let response = null;
            if (this.resolvedErrorHandler.type === 'function') {
                response = await this.resolvedErrorHandler.handler(error, ctx);
            }
            else {
                response = await this.resolver.call(this.resolvedErrorHandler, undefined, [error, ctx]);
            }
            return response || this.serializeError(error);
        }
        catch (finalError) {
            /*
             * Unexpected block
             */
            ctx.logger.fatal(finalError, 'Unexpected exception raised from WS ExceptionHandler "handle" method');
            return this.serializeError(error);
        }
    }
    /**
     * Report error when report method exists
     */
    async reportError(error, ctx) {
        if (!this.resolvedErrorReporter) {
            return;
        }
        try {
            await this.resolver.call(this.resolvedErrorReporter, undefined, [error, ctx]);
        }
        catch (finalError) {
            ctx.logger.fatal(finalError, 'Unexpected exception raised from WS ExceptionHandler "report" method');
        }
    }
    /**
     * Handle the error
     */
    async handle(error, ctx) {
        const response = await this.handleError(error, ctx);
        this.reportError(error, ctx);
        return response;
    }
}
exports.ExceptionManager = ExceptionManager;
