"use strict";
/*
 * @ruby184/adonis-socket.io
 *
 * (c) Ľubomír "Ruby" Jesze <lubomir.j184@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreCompiler = void 0;
const haye_1 = __importDefault(require("haye"));
const co_compose_1 = require("co-compose");
const utils_1 = require("@poppinss/utils");
class PreCompiler {
    constructor(container, middlewareStore) {
        this.middlewareStore = middlewareStore;
        /**
         * Method to execute middleware using the middleware store
         */
        this.executeMiddleware = (middleware, params) => {
            return this.middlewareStore.invokeMiddleware(middleware, params);
        };
        /**
         * Method to execute handler for connection, disconnect or disconnecting events
         */
        this.runConnectionHandler = (event, ctx, reason) => {
            const routeHandler = ctx.namespace.meta.resolvedHandlers[event];
            if (routeHandler.type === 'function') {
                return routeHandler.handler(ctx, reason);
            }
            return this.resolver.call(routeHandler, undefined, [ctx].concat(reason));
        };
        this.resolver = container.getResolver(undefined, 'wsControllers', 'App/Controllers/Ws');
    }
    compileHandlers(nsp) {
        nsp.meta.resolvedHandlers = {};
        for (const [event, handler] of Object.entries(nsp.handlers)) {
            if (typeof handler === 'string') {
                nsp.meta.resolvedHandlers[event] = this.resolver.resolve(handler, nsp.meta.namespace);
            }
            else if (handler) {
                nsp.meta.resolvedHandlers[event] = { type: 'function', handler };
            }
        }
    }
    compileMiddleware(nsp) {
        const list = nsp.middleware.map((item) => {
            if (typeof item === 'function') {
                return { type: 'function', value: item, args: [] };
            }
            /*
             * Extract middleware name and args from the string
             */
            const [{ name, args }] = haye_1.default.fromPipe(item).toArray();
            const resolvedMiddleware = this.middlewareStore.getNamed(name);
            if (!resolvedMiddleware) {
                throw new utils_1.Exception(`Cannot find a ws middleware named "${name}"`, 500, 'E_MISSING_NAMED_WS_MIDDLEWARE');
            }
            return { ...resolvedMiddleware, args };
        });
        nsp.meta.resolvedMiddleware = new co_compose_1.Middleware()
            .register(this.middlewareStore.get())
            .register(list);
    }
    compileNamespace(nsp) {
        this.compileHandlers(nsp);
        this.compileMiddleware(nsp);
    }
    /**
     * Method to run middleware chain for given namespace
     */
    async runNamespaceMiddleware(ctx) {
        const runner = ctx.namespace.meta.resolvedMiddleware.runner().executor(this.executeMiddleware);
        if (ctx.namespace.meta.resolvedHandlers.connection) {
            runner.finalHandler(this.runConnectionHandler, ['connection', ctx]);
        }
        return runner.run([ctx]);
    }
    /**
     * Method to run event handler with given args
     */
    async runEventHandler(event, ctx, args) {
        const routeHandler = ctx.namespace.meta.resolvedHandlers[event];
        if (typeof routeHandler === 'undefined') {
            throw new utils_1.Exception(`Cannot find a handler for event "${event}" in namespace "${ctx.namespace.pattern}"`, 500, 'E_MISSING_EVENT_HANDLER');
        }
        if (routeHandler.type === 'function') {
            return routeHandler.handler(ctx, ...args);
        }
        return this.resolver.call(routeHandler, undefined, [ctx].concat(args));
    }
}
exports.PreCompiler = PreCompiler;
