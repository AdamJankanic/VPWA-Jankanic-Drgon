"use strict";
/*
 * @ruby184/adonis-socket.io
 *
 * (c) Ľubomír "Ruby" Jesze <lubomir.j184@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsNamespace = void 0;
const helpers_1 = require("@poppinss/utils/build/helpers");
const macroable_1 = require("macroable");
class WsNamespace extends macroable_1.Macroable {
    constructor(pattern, globalMatchers) {
        super();
        this.pattern = pattern;
        this.globalMatchers = globalMatchers;
        /**
         * An object of matchers to be forwarded to the
         * store. The matchers list is populated by
         * calling `where` method
         */
        this.matchers = {};
        this.handlers = {};
        /**
         * An array of middlewares. Added using `middleware` function
         */
        this.middlewares = [];
    }
    static normalize(ns) {
        if (ns === '/') {
            return '/';
        }
        return `/${ns.replace(/^\//, '').replace(/\/$/, '')}`;
    }
    /**
     * Returns an object of param matchers by merging global and local
     * matchers. The local copy is given preference over the global
     * one's
     */
    getMatchers() {
        return Object.assign({}, this.globalMatchers, this.matchers);
    }
    addHandler(event, handler) {
        if (this.handlers[event]) {
            throw new Error('Duplicate event handler');
        }
        this.handlers[event] = handler;
        return this;
    }
    where(param, matcher) {
        if (typeof matcher === 'string') {
            this.matchers[param] = { match: new RegExp(matcher) };
        }
        else if (helpers_1.types.isRegexp(matcher)) {
            this.matchers[param] = { match: matcher };
        }
        else {
            this.matchers[param] = matcher;
        }
        return this;
    }
    /**
     * Define controller namespace for a given route
     */
    namespace(namespace) {
        this.controllerNamespace = namespace;
        return this;
    }
    on(event, handler) {
        return this.addHandler(event, handler);
    }
    middleware(middleware) {
        this.middlewares.push(Array.isArray(middleware) ? middleware : [middleware]);
        return this;
    }
    connected(handler) {
        return this.addHandler('connection', handler);
    }
    disconnecting(handler) {
        return this.addHandler('disconnecting', handler);
    }
    disconnected(handler) {
        return this.addHandler('disconnect', handler);
    }
    toJSON() {
        return {
            pattern: this.pattern,
            handlers: this.handlers,
            matchers: this.getMatchers(),
            middleware: this.middlewares.flat(),
            meta: {
                namespace: this.controllerNamespace,
            },
        };
    }
}
exports.WsNamespace = WsNamespace;
WsNamespace.macros = {};
WsNamespace.getters = {};
