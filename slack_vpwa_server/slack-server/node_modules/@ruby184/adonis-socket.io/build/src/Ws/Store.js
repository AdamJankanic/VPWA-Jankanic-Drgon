"use strict";
/*
 * @ruby184/adonis-socket.io
 *
 * (c) Ľubomír "Ruby" Jesze <lubomir.j184@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Store = void 0;
const matchit_1 = __importDefault(require("@poppinss/matchit"));
const utils_1 = require("@poppinss/utils");
class Store {
    constructor() {
        this.tree = { tokens: [], static: {}, dynamic: {} };
    }
    add(nsp) {
        const tokens = matchit_1.default.parse(nsp.pattern, nsp.matchers);
        const collectedParams = new Set();
        let isDynamic = false;
        /**
         * Avoiding duplicate route params
         */
        for (const token of tokens) {
            if ([1, 3].includes(token.type)) {
                if (collectedParams.has(token.val)) {
                    throw new utils_1.Exception(`The "${token.val}" param is mentioned twice in the namespace pattern "${nsp.pattern}"`, 500, 'E_DUPLICATE_NAMESPACE_PARAM');
                }
                else {
                    collectedParams.add(token.val);
                }
                isDynamic = true;
            }
            else if (token.type === 2) {
                // if it is a wildcard
                isDynamic = true;
            }
        }
        collectedParams.clear();
        const namespace = utils_1.lodash.pick(nsp, [
            'pattern',
            'handlers',
            'meta',
            'middleware',
        ]);
        if (isDynamic) {
            this.tree.tokens.push(tokens);
            this.tree.dynamic[nsp.pattern] = namespace;
        }
        else {
            this.tree.static[nsp.pattern] = namespace;
        }
        return this;
    }
    statics() {
        return Object.keys(this.tree.static);
    }
    isDynamic(name) {
        return !this.tree.static[name] && matchit_1.default.match(name, this.tree.tokens).length > 0;
    }
    match(name) {
        if (this.tree.static[name]) {
            return {
                namespace: this.tree.static[name],
                params: {},
            };
        }
        const matched = matchit_1.default.match(name, this.tree.tokens);
        if (!matched.length) {
            return null;
        }
        return {
            namespace: this.tree.dynamic[matched[0].old],
            params: matchit_1.default.exec(name, matched),
        };
    }
}
exports.Store = Store;
