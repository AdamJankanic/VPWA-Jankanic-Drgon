"use strict";
/*
 * @ruby184/adonis-socket.io
 *
 * (c) Ľubomír "Ruby" Jesze <lubomir.j184@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerExecutor = void 0;
const ExceptionManager_1 = require("../ExceptionManager");
class HandlerExecutor {
    constructor(application, precompiler, store, io) {
        this.application = application;
        this.precompiler = precompiler;
        this.store = store;
        this.io = io;
        /**
         * Exception manager to handle exceptions
         */
        this.exception = new ExceptionManager_1.ExceptionManager(this.application.container);
        /**
         * Resolve bindings required for creating context from container
         */
        this.Server = this.application.container.resolveBinding('Adonis/Core/Server');
        this.Request = this.application.container.resolveBinding('Adonis/Core/Request');
        this.Response = this.application.container.resolveBinding('Adonis/Core/Response');
        this.WsContext = this.application.container.resolveBinding('Ruby184/Socket.IO/WsContext');
        this.encryption = this.application.container.resolveBinding('Adonis/Core/Encryption');
        this.nsp = null;
        this.handleConnection = (socket) => {
            const ctx = socket.ctx;
            for (const evt of ['disconnecting', 'disconnect']) {
                if (ctx.namespace.meta.resolvedHandlers[evt]) {
                    socket.on(evt, async (reason) => {
                        try {
                            await this.precompiler.runConnectionHandler(evt, ctx, reason);
                        }
                        catch (error) {
                            await this.exception.handle(error, ctx);
                        }
                    });
                }
            }
            socket.onAny(async (event, ...args) => {
                const ack = args.length > 0 && typeof args[args.length - 1] === 'function' ? args.pop() : () => { };
                try {
                    ack(null, await this.precompiler.runEventHandler(event, ctx, args));
                }
                catch (error) {
                    ack(await this.exception.handle(error, ctx), null);
                }
            });
            socket.on('error', async (error) => {
                await this.exception.handle(error, ctx);
            });
        };
        this.addMiddlewareToNamespace = (namespace) => {
            const matched = this.store.match(namespace.name);
            if (!matched) {
                return;
            }
            namespace.use(async (socket, next) => {
                const ctx = this.getContext(socket, matched);
                try {
                    await this.precompiler.runNamespaceMiddleware(ctx);
                    next();
                }
                catch (error) {
                    next(await this.exception.handle(error, ctx));
                }
            });
            namespace.on('connect', this.handleConnection);
        };
    }
    getContext(socket, matched) {
        // TODO: we should not create and use response, but return Proxy to intercept and throw error when user tries to use response
        const request = new this.Request(socket.request, socket.request['res'], this.encryption, this.Server['httpConfig']);
        const response = new this.Response(socket.request, socket.request['res'], this.encryption, this.Server['httpConfig'], this.Server.router);
        const data = { namespace: socket.nsp.name, socket_id: socket.id };
        const ctx = new this.WsContext(request, response, this.application.logger.child(data), this.application.profiler.create('ws:connection', data), socket);
        ctx.namespace = matched.namespace;
        ctx.params = matched.params;
        // TODO: just here for compatibility with http context
        ctx.routeKey = socket.nsp.name;
        ctx.request.updateParams(ctx.params);
        return ctx;
    }
    attach(socketConfig, exceptionHandler) {
        if (!this.Server.instance) {
            return false;
        }
        if (exceptionHandler) {
            this.exception.registerHandler(exceptionHandler);
        }
        // first define static namespaces to socket.io
        for (const nsp of this.store.statics()) {
            this.addMiddlewareToNamespace(this.io.of(nsp));
        }
        // add checking of dynamic namespaces
        this.nsp = this.io.of((name, _, next) => next(null, this.store.isDynamic(name)));
        // when new dynamic namespace is created add middleware to it
        this.io.on('new_namespace', this.addMiddlewareToNamespace);
        // finally attach socket.io to adonis http server
        this.io.attach(this.Server.instance, socketConfig);
        return true;
    }
}
exports.HandlerExecutor = HandlerExecutor;
